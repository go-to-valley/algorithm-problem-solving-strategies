# 22. Binary Search Tree


2020.04.03

Seungrok Lee


## 정의
우선 이진트리부터 설명을 하면 각 노드가 최대 두 개의 자식 노드만을 가질 수 있는 트리를 의미한다. 따라서 이진 트리는 자식 노드들의 배열 대신 
두 개의 포인터 `left`와 `right`를 담는 객체로 구현된다. 이진 검색 트리는 이진 탐색에서 아이디어를 가져와서 만든 트리로 각 노드의 왼쪽 서브트리에는 
해당 노드의 원소보다 작은 원소를 가진 노드들이, 오른쪽에는 큰 원소를 가진 노드들이 들어간다. 따라서 이진 검색 트리에서 원하는 값을 찾는 과정은 
배열에서의 이진 탐색과 비슷하다. 표준 라이브러리에 구현이 되어 있으나, 제공하지 않는 연산을 수행할 경우 직접 구현해야 한다.

이진 검색 트리를 `inorder traverse`하면 크기 순서로 정렬된 원소의 목록을 얻을 수 있다.

## 장점
이진 검색 트리의 장점은 집합에 원소를 추가하거나 삭제하는 조작 연산을 해야하는 때이다. 배열에서 원소를 삽입하려면 삽입할 위치를 찾고 삽입 후에 
뒤의 원소들을 한 칸씩 뒤로 옮겨야 하지만 이진 검색 트리에서는 삽입할 위치를 찾고 노드를 생성하기만 하면 된다. 이진 검색 트리에서 삭제는 `합치기` 
방법으로 구현한다. 삭제할 위치를 찾고 노드를 없앤 후에 왼쪽 서브트리의 루트를 삭제한 위치에 넣고, 그 서브트리의 오른쪽 서브트리를 삭제한 노드의 
오른쪽 서브트리의 가장 작은 노드의 자식 노드로 합치면 된다. 

## 시간 복잡도 분석과 균형 잡힌 이진 검색 트리
이진 검색 트리에 대한 모든 연산은 모두 루트에서부터 한 단계식 트리를 내려가며 재귀 호출을 통해 수행하므로 최대 재귀 호출의 횟수는 트리의 높이 h와
같다. 즉 모든 연산이 `O(h)`가 된다. 그렇기 때문에 이진 검색 트리의 이상적인 케이스는 좌우 균형이 맞는 트리이다. 이런 트리에는 AVL 트리, 레드 블랙 
트리 등 다양한 트리가 있지만 이들 모두 구현이 까다롭기에 `트립(treap)`을 사용한다.

## 트립 구현
```c++
typedef int KeyType;
struct Node{
    KeyType key;
    int priority, size;
    Node *left, *right;
    Node(const KeyType& _key) : key(_key), priority(rand()), size(1), left(NULL), right(NULL) { }
    void setLeft(Node* newLeft) {left=newLeft; calcSize();}
    void setRight(Node* newRight) {right=newRight; calcSize();}
    void calcSize(){
        size=1;
        if(left) size += left->size;
        if(right) size += right->size;
    }
}
```
