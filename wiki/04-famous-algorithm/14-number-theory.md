# 14. Number Theory

2020.08.13.

Seungrok Lee



## 소수

소수(prime number)는 정수론의 가장 중요한 연구 대상 중 하나로, 양의 약수가 1과 자기 자신 두 개 뿐인 자연수를 의미한다.

### 소수 판별

주어진 수가 소수인지 확인하는 가장 기초적인 문제이다. 판별하는 가장 단순한 방법은 2부터 sqrt(n)까지 모든 수를 순회하면서 약수가 있는지 없는지를 체크하면 된다.


### 소인수 분해

한 합성수를 소수들의 곱으로 표현하는 방법을 찾는 것을 소인수 분해라고 한다. 가장 쉬운 방법은 2부터 시작해 n의 소인수가 될 수 있는 수들을 하나하나 순회하면서, n의 약수를 찾을 때마다 n을 이수로 나눈다. 이 알고리즘은 sqrt(n)번 반복문을 돌기 때문에 시간 복잡도는 O(sqrt(n))이 된다.


### 에라토스테네스의 체

주어진 수 n 이하의 모든 소수를 찾는 방법이다. 2부터 시작해서 소수의 배수들을 계속해서 모두 지워나가는 방법이다. 이 때 최적화하는 방법은 i의 배수들을 지워나갈 때 2*i 가 아닌 i*i부터 시작하는 것이다.



## 유클리드 알고리즘

유클리드 알고리즘은 두 수의 최대공약수를 구하는 방법으로, 기록이 남아 있는 가장 오래된 알고리즘으로 유명하다. p,q의 공약수의 집합은 p-q와 q의 공약수의 집합과 같다는 것을 이용한다. 

```c++
int gcd(int p, int q)
{
    if(p<q) swap(p,q);
    if(q==0) return p;
    return gcd(p-q, q);
}
```

좀 더 최적화를 하면 다음과 같다.

```c++
int gcd(int p, int q)
{
    if(q==0) return p;
    return gcd(q, p%q);
}
```



## 모듈라 연산

모듈라 연산에서 덧셈, 뺄셈, 그리고 곱셈은 다음과 같다.
* (a+b)%M = ((a%M)+(b%M))%M
* (a-b)%M = ((a%M)-(b%M)+M)%M
* (aXb)%M = ((a%M)X(b%M))%M

나눗셈에서는 일반적인 공식이 성립하지 않고 곱셈의 역원을 이용한다. 이 때 곱셈의 역원은 b와 M이 서로소일 때만 존재한다. b의 역원 modInv(b,M)은 다음과 같이 정의된다.
* modInv(b,M) = (b^M-2)%M

따라서 나눗셈은 다음과 같이 계산할 수 있다.
* (a/b)%M = (aXmodInv(b,M))%M

## Problems

- [비밀번호 486(ID: PASS486, 난이도: 중)](https://www.algospot.com/judge/problem/read/PASS486)
- [마법의 약(ID: POTION, 난이도: 중)](https://www.algospot.com/judge/problem/read/POTION)
