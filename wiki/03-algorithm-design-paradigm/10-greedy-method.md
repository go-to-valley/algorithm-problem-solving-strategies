# 10. 탐욕법

## 도입

탐욕법은 원하는 답을 재귀 호출과 같이 여러 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획 알고리즘과 다를 것이 없으나, 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.

탐욕적 알고리즘은 많은 경우 최적해를 찾지 못하기에 다음 두 가지 경우에만 사용이 제한된다.

1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만나 경우
2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 어려울 경우 근사해를 찾을 때

실제 프로그래밍 문제에서는 근사해를 찾을 필요가 없기에 1번 경우에만 탐욕법을 사용한다. 이 경우 탐욕법은 동적 계획법보다 수행시간이 훨씬 빠르기에 유리하다.

탐욕법은 간단하지만 탐욕적으로 선택할 수 있는 방법이 여러가지가 있기에 어느 방법이 최적해를 구할 수 있는 방법인지 선택하기가 어렵다. 따라서 탐욕법을 풀 때 정당성을 증명하는 과정을 항상 거쳐 연습하는 것이 중요하다.

## 예제: 회의실 예약

활동 선택 문제(activity selection problem)의 경우는 탐욕법이 유용하게 사용되는 문제이다.

회사에 회의실이 하나밖에 없는데 n(≤100)개의 팀이 각각 회의하고 싶은 시간을 제출했을 때, 겹치지 않는 회의를 최대 몇 개를 선택할 수 있을까?

### 무식하게 풀 수 있을까?

가장 단순하게 푸는 방법은 전체 부분집합 중에서 조건을 만족시키는 가장 큰 부분집합을 찾는 것이다. 이 경우 부분 집합의 개수가 2^n개 이기에 n이 30만 넘어가도 시간을 만족하기 힘들다.

### 탐욕적 알고리즘의 구상

위에서 언급했듯이 탐욕적 선택 방법은 여러개가 될 수 있고, 그 중 최적해를 찾을 수 있는 방법을 선택해야 한다. 예를 들어 길이가 가장 짧은 회의부터 순회하며 앞의 것들과 겹치지 않는 것들을 추가하는 것은 방법이 있다. 이 방법은 회의실이 사용 가능한 시간을 최대화 하려고 하기에 그럴듯 해보이나 항상 정답을 도출하지는 않는다.

이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 가장 먼저 끝나는 회의부터 선택하고, 그 회의와 시간이 겹치는 회의를 다 지운 후 다시 가장 먼저 끝나는 회의를 선택하는 방법이다. 이를 정리하면 다음과 같다.

1. 목록 S에 남은 회의중 가장 일찍 끝나는 회의 Smin을 선택한다.
2. Smin과 겹치는 회의를 S에서 모두 지운다.
3. S가 빌 때까지 반복한다.

### 정당성 증명: 탐욕적 선택 속성

탐욕적 알고리즘의 정당성 증명은 두 가지 속성을 증명함으로써 보인다. 그 중 첫번째 속성이 바로 모든 부분을 고려하지 않고 탐욕적 선택만으로도 최적해를 구할 수 있다는 탐욕적 선택 속성(greedy choice property)이다.

위에서 선택한 알고리즘의 탐욕적 선택 속성이 성립한다는 것은 다음 조건이 성립한다는 것이다.

_가장 종료 시간이 빠른 회의(Smin)을 포함하는 최적해가 반드시 존재한다._

S의 최적해 중에 Smin을 포함하지 않는 답이 있다고 가정하자. 여기서 가장 첫번째 개최되는 회의 대신 Smin을 목록에 넣는다고 하자. Smin은 목록에서 빠지는 회의보다 더 일찍 끝나기 때문에 목록의 두 번째 회의와 겹칠일이 없다. 따라서 이 경우에도 최적해가 성립한다.

### 최적 부분 구조

탐욕적 선택 속성이 증명됐다면 그 다음은 항상 최적의 선택을 내리는 것이 전체의 최적해를 구할 수 있는지 증명해야한다. 대부분의 경우는 되게 자명해서 증명 필요가 없지만 경우에 따라 성립하지 않는 경우가 있다.

### 구현

이 알고리즘의 쉽고 빠른 구현 방법은 모든 회의를 종료시간의 오름차순으로 정렬하는 것이다. 이 경우 탐욕적 선택에는 O(n)만이 걸리기에 전체 수행시간은 정렬에 필요한 O(nlogn)이다.

### 동적 계획법으로

다음같이 부분문제를 정의하자.

schedule(idx) = meeting[idx] 혹은 그 이전에 끝나는 회의들 중 선택할 수 있는 최대 회의의 수

idx번 회의가 시작하기 전에 끝나는 회의들 중 마지막 회의의 번호를 before[idx]에 저장했다고 하면 부분문제는 다음 점화식으로 표현 가능하다.

schedule(idx) = max(schedule(idx - 1), 1 + schedule(before[idx]))

사실 대부분의 탐욕법 문제는 동적 계획법으로도 해결이 가능하다. 하지만 탐욕법을 사용해서 풀 수 있다면 이를 이용하는게 메모리, 시간 모두에서 유리하다. 다음은 동적 계획법으로 풀기는 너무 시간이 오래 걸리는 예제이다.

## 예제: 출전 순서 정하기(문제 ID: MATCHORDER, 난이도: 하)

[링크](https://algospot.com/judge/problem/read/MATCHORDER)

### 무식하게

n!개의 순열을 만들어 해결 가능하다.

### 동적 계획법

n!개의 답을 생성하는 완전 탐색에 메모이제이션을 적용한다.

order(taken) = 각 한국팀 선수를 이미 순서에 추가했는지의 여부가 taken에 주어질 때, 남은 선수들을 적절히 배치해서 얻을 수 있는 최대 승수

taken에 포함된 true의 수를 세면 이번에 선택할 선수가 러시아팀의 어떤 선수와 경기하게 되는지도 알 수 있으니 taken이외의 다른 인자는 필요 없고 이 경우 O(n\*2^n)시간의 동적 계획 알고리즘을 얻을 수 있다.

### 탐욕적 알고리즘의 구상

맨 앞 경기부터 한 명씩 출전할 한국 선수를 정한다고 하자. 이 때 다음 두 가지를 고려하여 선택하면 된다.

1. 상대방 선수를 이길 수 있는 한국 선수가 있는 경우 그 중 가장 레이팅이 낮은 선수를 선택
2. 상대방 선수를 이길 수 있는 한국 선수가 없을 경우 전체에서 가장 레이팅이 낮은 선수를 선택

### 탐욕적 선택 속성 증명

위에서 두 가지 경우를 나누어 선택을 했기에 똑같이 각 경우에 대해 증명을 하면 된다.

먼저 상대방을 이길 수 있는 한국 선수가 있을 경우를 보자. 이 중에서 가장 레이팅이 낮은 선수 A와 다른 선수 B가 있을 때 여기서 최적해로 B를 선택했다고 가정하자. 이 경우 나중에 A가 상대할 선수가 x라고 하면, A와 B의 순서를 바꿔도 어짜피 이번 경기는 무조건 승리를 하게 되며, x의 경우 A보다 레이팅이 높은 B를 상대하기에 똑같이 최적해 임을 알 수 있다. 반대로 A보다 레이팅이 낮은 C를 선택하는 최적해가 있다고 치면, 이 경기는 지게된다. 만약 A와 C의 위치를 바꾸게 된다면 이 경기를 무조건 이기게 되고 원래 A가 했던 경기를 C가 대신 치뤄서 질 수 있다고 해도 승수가 1늘고 1줄었기에 결과적으로는 최적해이다. 따라서 A를 선택하는 것이 최적해임을 보장하는 것을 알 수 있다.

다음으로 상대방을 이길 수 있는 한국 선수가 없을 경우를 보자. 똑같이 여기서 가장 레이팅이 낮은 선수 A와 그보다 높은 B가 있을 때, B를 선택하는 최적해가 있다고 하자. 여기서 두 선수의 순서를 바꿀 경우 A를 상대했던 선수 x는 A보다 레이팅이 더 높은 선수 B를 상대하기에 승수가 줄어들 일은 없게 된다. 따라서 이 경우에도 A를 내보내는 최적해가 있음을 알 수 있다.

### 최적 부분 구조 증명

첫 번째 경기에 나갈 선수를 선택하고 나면 남은 선수들을 경기에 배정하는 부분 문제를 얻을 수 있다. 이 때 남은 경기에서도 당연히 최다승을 얻는 것이 좋으니 최적 부분 구조도 자명하게 성립한다.

## 탐욕적 알고리즘 레시피

1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.

2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다. 직관을 얻기 위해 예제 입력이나 그 외의 작은 입력을 몇 개 손으로 풀어 보는 것이 효율적이다.

3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명해 본다.

   a. 탐욕적 선택 속성: 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면 된다. 대게 선택한 답과 다른 최적해가 존재함을 가정해고 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있다는 것을 보여 증명한다.

   b. 최적 부분 구조: 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명하며 대부분의 경우 자명하게 알 수 있다.

## 문제

1. [도시락 데우기 (문제 ID: LUNCHBOX, 난이도: 하)](https://www.algospot.com/judge/problem/read/LUNCHBOX)
2. [문자열 합치기 (문제 ID: STRJOIN, 난이도: 중)](https://www.algospot.com/judge/problem/read/STRJOIN)
3. [미나스 아노르 (문제 ID: MINASTIRITH, 난이도: 상)](https://www.algospot.com/judge/problem/read/MINASTIRITH)
